local Args = {...}
local Branches = 0
local Trunks = 0
local PlaceTorches = true
local Channel = nil
local TurtleID = os.getComputerLabel()
local TorchesSlot = 15
local FuelSlot = 16

local tBranchesMined = 0
local tTrunksMined = 0
local tSide = "Left"
local tMovements = {}
local tBackMovements = {}

if turtle == nil then
    print("Error: This is a turtle program and cannot be used by a computer")
end

if TurtleID == nil then
    TurtleID = "#" .. os.getComputerID()
end

if #Args < 2 then
    print("Syntax: turtle <Trunks> <Branches> {Torches=True} {Channel=nil}")
    print("<Trunks>: Amount of Trunks to make (Required)")
    print("<Branches>: Amount of Branches to make per Trunk (Required)")
    print("{Torches}: Place Torches along the way. Slots should be in slot " .. TorchesSlot .. ". (Default: True) (Optional)")
    print("{Channel}: Channel name (Used by zReceiver) (Default:None/No Broadcast) (Optional)")
    return false
end

Trunks = tonumber(Args[1])
Branches = tonumber(Args[2])

if #Args >= 4 then
    Channel = Args[4]
end

if #Args >= 3 then
    PlaceTorches = (Args[3] == "True" or Args[3] == "true")
end

local function SendMessage(Msg)
    if peripheral.getType("right") == "modem" and Channel ~= nil then
        rednet.open("right")
        rednet.broadcast(Channel .. "|" .. TurtleID .. ": " .. Msg)
        rednet.close("right")
    end
    print(Msg)
end

local function CalcMovementsRequired(lTrunks, lBranches)
      return (13 * lTrunks) - 6 + ((28 * lBranches * 2) * lTrunks)
end

local function Refuel(Needed)
    if turtle.getFuelLevel() >= Needed then
        return true
    end
    for I=1, 16 do
        turtle.select(I)
        while turtle.getFuelLevel() < Needed do
            if not turtle.refuel(1) then
                break
            end
        end
        
        if turtle.getFuelLevel() >= Needed then
            return true
        end
    end
    
    return false
end

local function HasInventoryLeft()
    for I=1, 16 do
        if turtle.getItemCount(I) == 0 then
            return true
        end
    end
    return false
end

local function TryForward()
    while not turtle.forward() do
        if turtle.detect() then
            while turtle.detect() do
                if not turtle.dig() then
                    return false
                end
                if not turtle.detect() then
                    break
                end
                os.sleep(0.5)
            end
        elseif turtle.getFuelLevel() <= 0 then
            turtle.select(FuelSlot)
            if not turtle.refuel(1) then
                SendMessage("Out of fuel on Trunk " .. tTrunksMined .. ", Branch " .. tBranchesMined .. ", Side: " .. tSide)
                while not turtle.refuel(1) do
                    os.sleep(1)
                end
                SendMessage("Waiting 5 Seconds...")
                os.sleep(5)
                SendMessage("Resuming Operation")
            end
        else
            turtle.attack()
            os.sleep(0.5)
        end
    
        --[[if turtle.getFuelLevel() <= 0 then
            turtle.select(FuelSlot)
            if not turtle.refuel(1) then
                SendMessage("Out of fuel on Trunk " .. tTrunksMined .. ", Branch " .. tBranchesMined)
                while not turtle.refuel(1) do
                    os.sleep(1)
                end
                SendMessage("Waiting 5 Seconds...")
                os.sleep(5)
                SendMessage("Resuming Operation")
            end
        elseif not turtle.detect() then
            turtle.attack()
            os.sleep(0.5)
        end
    
        while turtle.detect() do
            if not turtle.dig() then
                return false
            end
            os.sleep(0.5)
        end]]--
    end
    return true
end

local function TryUp()
    if not turtle.up() then
        if turtle.detectUp() then
            if not turtle.digUp() then
                return false
            end
        else
            while not turtle.up() do
                turtle.attackUp()
                os.sleep(0.5)
            end
        end
    end
    return true
end

local function TryDown()
    if not turtle.down() then
        if turtle.detectDown() then
            if not turtle.digDown() then
                return false
            end
        else
            while not turtle.down() do
                turtle.attackDown()
                os.sleep(0.5)
            end
        end
    end
    return true
end

local function TurnLeft()
    return turtle.turnLeft()
end

local function TurnRight()
    return turtle.turnRight()
end

local function RetrackBack(ReturnToLocation)
    SendMessage("Returning to start position")
    tBackMovements = {}
    for I=1, #tMovements do
        if tMovements[I] == "Forward" then
            TryForward()
            table.insert(tBackMovements, #tBackMovements + 1, "Forward")
        elseif tMovements[I] == "Back" then
            turtle.back()
            table.insert(tBackMovements, #tBackMovements + 1, "Back")
        elseif tMovements[I] == "Left" then
            TurnLeft()
            table.insert(tBackMovements, #tBackMovements + 1, "Right")
        elseif tMovements[I] == "Right" then
            TurnRight()
            table.insert(tBackMovements, #tBackMovements + 1, "Left")
        end
    end
    
    for I=1, ((tTrunksMined + 1) * 13 - 6) do
        TryForward()
        table.insert(tBackMovements, #tBackMovements + 1, "Forward")
    end
    
    SendMessage("Unloading Items")
    for I=1, 16 do
        if I ~= TorchesSlot and I ~= FuelSlot then
            turtle.select(I)
            turtle.dropDown()
        end
    end
    
    
    SendMessage("Returning to last mined position")
    if ReturnToLocation then
        TurnLeft()
        TurnLeft()
        for I=#tBackMovements, 1, -1 do
            if tBackMovements[I] == "Forward" then
                TryForward()
            elseif tBackMovements[I] == "Back" then
                turtle.back()
            elseif tBackMovements[I] == "Left" then
                TurnLeft()
            elseif tBackMovements[I] == "Right" then
                TurnRight()
            end
            turtle.suckDown() --Pick up and overflowing items from before
        end
        TurnRight()
        TurnRight()
    end
    return true
end


local function MineBranch(lPlaceTorch, Times)
    local Turn = "Right"
    tSide = "Left"
    if Times == 2 then
        Turn = "Left"
        tSide = "Right"
    end
    
    tMovements = {}
    for I=1, 4 do
        if not TryForward() then
            return false
        end
        
        if turtle.detectDown() then
            if not turtle.digDown() then
                return false
            end
        end
    end
    tMovements = {"Right","Right","Forward","Forward","Forward","Forward", Turn}
    if not HasInventoryLeft() then
        RetrackBack(true)
    end
    TurnLeft()
    for I=1, 5 do
        if not TryForward() then
            return false
        end
    end
    TurnLeft()
    TurnLeft()
    
    tMovements = {"Forward","Forward","Forward","Forward","Forward","Right","Forward","Forward","Forward","Forward", Turn}
    if not HasInventoryLeft() then
        RetrackBack(true)
    end
    
    for I=1, 5 do
        if not TryForward() then
            return false
        end
    end
    
    tMovements = {"Right","Forward","Forward","Forward","Forward", Turn}
    if not HasInventoryLeft() then
        RetrackBack(true)
    end
    
    for I=1, 5 do
        if not TryForward() then
            return false
        end
    end
    TurnLeft()
    TurnLeft()
    
    tMovements = {"Forward","Forward","Forward","Forward","Forward","Left","Forward","Forward","Forward","Forward", Turn}
    if not HasInventoryLeft() then
        RetrackBack(true)
    end
    
    for I=1, 5 do
        if not TryForward() then
            return false
        end
    end
    
    if lPlaceTorch and PlaceTorches and turtle.getItemCount(TorchesSlot) > 0 then
        turtle.select(TorchesSlot)
        turtle.placeDown()
    end
    return true
end

local function MineTrunk(lBranches)
    for I=1,7 do
        if not TryForward() then
            return false
        end
        
        if turtle.detectDown() then
            if not turtle.digDown() then
                return false
            end
        end
    end
    
    TurnLeft()
    for B=1, 2 do
        tBranchesMined = 0
        local lPlaceTorch = true
        for I=1, lBranches do
            if not MineBranch(lPlaceTorch, B) then
                return false
            end
            tBranchesMined = tBranchesMined + 1
            
            if not HasInventoryLeft() then
                local WhichTurn = "Right"
                if B == 2 then
                    WhichTurn = "Left"
                end
                tMovements = {"Left"}
                for M=1, tBranchesMined * 4 do
                    table.insert(tMovements, #tMovements + 1, "Forward")
                end
                table.insert(tMovements, #tMovements + 1, WhichTurn)
                os.sleep(1)
                RetrackBack(true)
            end
            
            if I < lBranches then
                TurnRight()
            else
                TurnLeft()
            end
            if lPlaceTorch then
                lPlaceTorch = false
            else
                lPlaceTorch = true
            end
        end
        for I=1, lBranches * 4 do
            if not TryForward() then
                return false
            end
        end
    end
    return true
end


local MovementsRequired = CalcMovementsRequired(Trunks, Branches)
if not Refuel(MovementsRequired) then
    print("Not enough fuel. Required Fuel Level: " .. MovementsRequired .. ". Please put enough fuel in Slot " .. FuelSlot)
    turtle.select(FuelSlot)
    while turtle.getFuelLevel() < MovementsRequired do
        if not turtle.refuel(1) then
            os.sleep(0.5)
        end
    end
end

if PlaceTorches then
    local TorchesNeeded = (Trunks * math.floor(Branches / 2) * 2)
    if turtle.getItemCount(TorchesSlot) < TorchesNeeded then
        print("Please put atleast " .. TorchesNeeded .. " torches in Slot " .. TorchesSlot)
        while turtle.getItemCount(TorchesSlot) < TorchesNeeded do
            os.sleep(1)
        end
    end
end

turtle.select(1)
for T=1, Trunks do
    if not MineTrunk(Branches) then
        if turtle.getFuelLevel() <= 0 then
            SendMessage("Not enough fuel?! Exiting Operation!")
            return false
        elseif turtle.detect() then
            if not turtle.dig() then
                SendMessage("We have hit bedrock here.. Unloading Items and quitting")
                RetrackBack(false)
                for I=1, 16 do
                    turtle.select(I)
                    turtle.drop()
                end
                return false
            end
        else
            SendMessage("Something went wrong.. Unloading Items and quitting")
            RetrackBack(false)
            for I=1, 16 do
                turtle.select(I)
                turtle.drop()
            end
            return false
        end
    end
    tTrunksMined = tTrunksMined + 1
    SendMessage("Trunk " .. tTrunksMined .. " of " .. Trunks .. " Mined")
    
    if T == Trunks then
        TurnLeft()
    else
        if not HasInventoryLeft then
            tMovements = {"Left"}
            RetrackBack(true)
        end
        
        TurnRight()
        for I=1, 6 do
            TryForward()
            if turtle.detectDown() then
                if not turtle.digDown() then
                    return false
                end
            end
        end
    end
end

for T=1, (Trunks * 13) - 6 do
    TryForward()
end
for I=1, 16 do
    turtle.select(I)
    turtle.dropDown()
end
TurnLeft()
TurnLeft()
SendMessage("Finished Operation")
return true
